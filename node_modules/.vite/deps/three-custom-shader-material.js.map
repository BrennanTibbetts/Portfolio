{
  "version": 3,
  "sources": ["../../three-custom-shader-material/dist/three-custom-shader-material.esm.js"],
  "sourcesContent": ["import { _ as _objectWithoutProperties, C as CustomShaderMaterial$1, a as _objectSpread2 } from './vanilla-307d3a93.esm.js';\nimport * as React from 'react';\nimport 'object-hash';\nimport 'three';\nimport 'glsl-tokenizer';\nimport 'glsl-token-string';\nimport 'glsl-token-functions';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nvar _excluded = [\"baseMaterial\", \"fragmentShader\", \"vertexShader\", \"uniforms\", \"cacheKey\", \"attach\"];\n// function useDidUpdateEffect(fn: (...opts: any[]) => any, inputs: React.DependencyList) {\n//   const didMountRef = React.useRef(false)\n\n//   React.useEffect(() => {\n//     if (didMountRef.current) {\n//       return fn()\n//     }\n//     didMountRef.current = true\n//   }, inputs)\n// }\nvar CustomShaderMaterial = /*#__PURE__*/React.forwardRef(function (_ref, ref) {\n  var baseMaterial = _ref.baseMaterial,\n    fragmentShader = _ref.fragmentShader,\n    vertexShader = _ref.vertexShader,\n    uniforms = _ref.uniforms,\n    cacheKey = _ref.cacheKey,\n    _ref$attach = _ref.attach,\n    attach = _ref$attach === void 0 ? 'material' : _ref$attach,\n    props = _objectWithoutProperties(_ref, _excluded);\n  var updateProps = React.useMemo(function () {\n    return {\n      fragmentShader: fragmentShader,\n      vertexShader: vertexShader,\n      uniforms: uniforms,\n      cacheKey: cacheKey\n    };\n  }, [fragmentShader, vertexShader, uniforms, cacheKey]);\n  var material = React.useMemo(function () {\n    return new CustomShaderMaterial$1(_objectSpread2(_objectSpread2({\n      baseMaterial: baseMaterial\n    }, updateProps), props));\n  }, [baseMaterial, updateProps]);\n  React.useEffect(function () {\n    return function () {\n      return material.dispose();\n    };\n  }, [material]);\n\n  // TODO: Use .update when it stop leaking memory\n  // useDidUpdateEffect(\n  //   () => material.update(updateProps),\n  //   [updateProps]\n  // )\n\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: material,\n    ref: ref,\n    attach: attach\n  }, props));\n});\n\nexport { CustomShaderMaterial as default };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AACA,YAAuB;AACvB,yBAAO;AAEP,4BAAO;AACP,+BAAO;AACP,kCAAO;AAEP,SAAS,WAAW;AAClB,aAAW,OAAO,SAAS,OAAO,OAAO,KAAK,IAAI,SAAU,QAAQ;AAClE,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,UAAI,SAAS,UAAU,CAAC;AACxB,eAAS,OAAO,QAAQ;AACtB,YAAI,OAAO,UAAU,eAAe,KAAK,QAAQ,GAAG,GAAG;AACrD,iBAAO,GAAG,IAAI,OAAO,GAAG;AAAA,QAC1B;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACA,SAAO,SAAS,MAAM,MAAM,SAAS;AACvC;AAEA,IAAI,YAAY,CAAC,gBAAgB,kBAAkB,gBAAgB,YAAY,YAAY,QAAQ;AAWnG,IAAIA,wBAA0C,iBAAW,SAAU,MAAM,KAAK;AAC5E,MAAI,eAAe,KAAK,cACtB,iBAAiB,KAAK,gBACtB,eAAe,KAAK,cACpB,WAAW,KAAK,UAChB,WAAW,KAAK,UAChB,cAAc,KAAK,QACnB,SAAS,gBAAgB,SAAS,aAAa,aAC/C,QAAQ,yBAAyB,MAAM,SAAS;AAClD,MAAI,cAAoB,cAAQ,WAAY;AAC1C,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF,GAAG,CAAC,gBAAgB,cAAc,UAAU,QAAQ,CAAC;AACrD,MAAI,WAAiB,cAAQ,WAAY;AACvC,WAAO,IAAI,qBAAuB,eAAe,eAAe;AAAA,MAC9D;AAAA,IACF,GAAG,WAAW,GAAG,KAAK,CAAC;AAAA,EACzB,GAAG,CAAC,cAAc,WAAW,CAAC;AAC9B,EAAM,gBAAU,WAAY;AAC1B,WAAO,WAAY;AACjB,aAAO,SAAS,QAAQ;AAAA,IAC1B;AAAA,EACF,GAAG,CAAC,QAAQ,CAAC;AAQb,SAA0B,oBAAc,aAAa,SAAS;AAAA,IAC5D,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,EACF,GAAG,KAAK,CAAC;AACX,CAAC;",
  "names": ["CustomShaderMaterial"]
}
